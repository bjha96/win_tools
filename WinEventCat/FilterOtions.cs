/*
* Author: Bimalesh Jha (46f6780b4f1beba64cf09a4fee5f0d657bc55a37c3a8feaba3023a5ac2f36d87).
* You may use, modify and distribute this code under the Apache License V2 (https://www.apache.org/licenses/LICENSE-2.0).
* This file was originally hosted at https://github.com/bjha96/WinEventCat.
*/

namespace WinEventCat
{
    class FilterOptions
    {
        //Sample XML events query can be generated by EventsViewer tool.
        /*
        Ex 1:
        <QueryList>
            <Query Id="0" Path="Application">
                <Select Path="Application">*[System[(Level=3 or Level=5) and (EventID=4673 or EventID=5678 or EventID=6789) and TimeCreated[@SystemTime&lt;='2023-04-26T12:07:11.999Z']]]</Select>
            </Query>
        </QueryList>

        Ex 2:
        <QueryList>
        <Query Id="0" Path="file://C:\Users\bjha\Downloads\temp\security.evtx">
            <Select Path="file://C:\Users\bjha\Downloads\temp\security.evtx">*[System[(Level=3 or Level=5) and (EventID=4663 or EventID=3456) and TimeCreated[@SystemTime&gt;='2023-04-23T12:09:45.000Z' and @SystemTime&lt;='2023-04-26T12:09:45.999Z']]]</Select>
        </Query>
        </QueryList>
        */
        private const string DATE_TIME_FORMAT = "yyyy-MM-ddThh:mm:ss.fffZ";

        public string? IncludeEventIds { get; set; }
        public string? ExcludeEventIds { get; set; }
        public string? Before { get; set; }
        public string? After { get; set; }
        public string? Between { get; set; }
        public string? LogLevel { get; set; }

        public DateTime BeforeAsDateTime 
        { 
            get {
                return ConvertToDateTime(Before ?? "");
            }
        }

        public DateTime AfterAsDateTime 
        { 
            get {
                return ConvertToDateTime(After ?? "");
            }
        }

        public DateTime[] BetweenAsDateTimes 
        { 
            get {
                
                DateTime[] dates = new DateTime[2]
                {
                    DateTime.MinValue, 
                    DateTime.MinValue
                };

                if(IsPropertySet(Between))
                {                    
                    var inputs = (Between ?? "").Split(',', 2);
                    dates[0] = ConvertToDateTime(inputs[0]);
                    dates[1] = ConvertToDateTime(inputs[1]);
                }

                return dates;
            }
        }

        static bool IsPropertySet(string? property)
        {
            return !String.IsNullOrEmpty(property);
        }

        bool IsFilterSet()
        {
            return (
                IsPropertySet(IncludeEventIds)
                    ||
                 IsPropertySet(ExcludeEventIds)
                    ||
                 IsPropertySet(Before)
                    ||
                 IsPropertySet(After)
                    ||
                 IsPropertySet(Between)
                    ||
                 IsPropertySet(LogLevel)
                );
        }

        /*
            * //no filter (all)
            *[System[(EventID=123 or EventID=345)]] //only event Id
            *[System[(Level=2 or Level=3)]] //Only log levels
            *[System[TimeCreated[timediff(@SystemTime) &lt;= 3600000]]] //Only dateTime
            *[System[(EventID=123 or EventID=345) and TimeCreated[timediff(@SystemTime) &lt;= 3600000]]] //events Id and Datetime
            *[System[(Level=3 or Level=5) and (EventID=4663 or EventID=3456) and TimeCreated[@SystemTime &gt;= '2023-04-23T12:09:45.000Z' and @SystemTime &lt;= '2023-04-26T12:09:45.999Z']]]
        */
        public string BuildXpathQuery(string logPath)
        {
            IList<string> xpSelectQuery = new List<string>();            
            xpSelectQuery.Add("*");

            string xpSuppressQuery = "";

            if (IsFilterSet())
            {                
                int qC = 0;                
                bool andC = false;

                if (IsPropertySet(LogLevel))
                {
                    if(qC == 0){
                        xpSelectQuery.Add("[System[");
                        qC = 2;       
                    }

                    xpSelectQuery.Add($"(Level &lt;= {GetLogLevel()})");
                    andC = true;
                }

                if (IsPropertySet(IncludeEventIds))
                {
                    if(qC == 0){
                        xpSelectQuery.Add("[System[");
                        qC = 2;       
                    }

                    string[] evtIds = (IncludeEventIds ?? "").Split(",", StringSplitOptions.RemoveEmptyEntries);

                    string incEvtIdQ = "";
                    const string OR_SEP = " or ";
                    foreach (var eid in evtIds)
                    {
                        int idV;
                        if (Int32.TryParse(eid, out idV))
                        {
                            incEvtIdQ += $"EventID = {idV}{OR_SEP}";
                        }
                    }

                    if (incEvtIdQ.Length > 0)
                    {
                        incEvtIdQ = incEvtIdQ.Substring(0, incEvtIdQ.Length - OR_SEP.Length); //delete last " or "
                        incEvtIdQ = $"({incEvtIdQ})";

                        if (andC)
                        {
                            xpSelectQuery.Add(" and ");
                        }
                        xpSelectQuery.Add(incEvtIdQ);
                        andC = true;
                    }
                }
                else if (IsPropertySet(ExcludeEventIds))
                {
                    //Generating following exclusion filter
                    //<Suppress Path="Application">*[System[(EventID=345 or EventID=445)]]</Suppress>
                    string[] evtIds = (ExcludeEventIds ?? "").Split(",", StringSplitOptions.RemoveEmptyEntries);

                    string excEvtIdQ = "";
                    const string OR_SEP = " or ";
                    foreach (var eid in evtIds)
                    {
                        int idV;
                        if (Int32.TryParse(eid, out idV))
                        {
                            excEvtIdQ += $"EventID = {idV}{OR_SEP}";
                        }
                    }

                    if (excEvtIdQ.Length > 0)
                    {
                        excEvtIdQ = excEvtIdQ.Substring(0, excEvtIdQ.Length - OR_SEP.Length); //delete last " or "                        
                        xpSuppressQuery = $"*[System[({excEvtIdQ})]]";
                    }
                }

                //Date time condition
                if(IsPropertySet(Before) || IsPropertySet(After) || IsPropertySet(Between))
                {            
                    if(qC == 0){
                        xpSelectQuery.Add("[System[");
                        qC = 2;       
                    }

                    //TimeCreated[@SystemTime &gt;= '2023-04-23T12:09:45.000Z' and @SystemTime &lt;= '2023-04-26T12:09:45.999Z']
                    string dQ = "";
                    if(AfterAsDateTime > DateTime.MinValue)
                    {
                        dQ = $"@SystemTime &gt;= '{AfterAsDateTime.ToString(DATE_TIME_FORMAT)}'";
                    }
                    else if(BeforeAsDateTime > DateTime.MinValue)
                    {
                        dQ = $"@SystemTime &lt;= '{BeforeAsDateTime.ToString(DATE_TIME_FORMAT)}'";
                    }
                    else //Between
                    {
                        var dates = BetweenAsDateTimes;
                        dQ = $"@SystemTime &gt;= '{dates[0].ToString(DATE_TIME_FORMAT)}' and @SystemTime &lt;= '{dates[1].ToString(DATE_TIME_FORMAT)}'";
                    }

                    if(dQ.Length > 0)
                    {                        
                        if(andC)
                        {
                            xpSelectQuery.Add(" and ");
                        }
                        xpSelectQuery.Add("TimeCreated[");
                        xpSelectQuery.Add(dQ);
                        qC = 3; // 3 closures ]]] at the end
                    }
                }

                //Closing ]
                for (int i = 0; i < qC; i++)
                {
                    xpSelectQuery.Add("]");
                }
            }

            var xpqe = String.Join("", xpSelectQuery);
            
            //Make final query
            string query;
            if(xpSuppressQuery.Length == 0)
            {
                query = $"<QueryList><Query Id=\"0\" Path=\"{logPath}\"><Select Path=\"{logPath}\">{xpqe}</Select></Query></QueryList>";
            }
            else //has exclude EventID filter for Suppressing
            {
                query = $"<QueryList><Query Id=\"0\" Path=\"{logPath}\"><Select Path=\"{logPath}\">{xpqe}</Select><Suppress Path=\"{logPath}\">{xpSuppressQuery}</Suppress></Query></QueryList>";
            }

            Console.WriteLine("Using query: " + query);
            return query;
        }


        internal byte GetLogLevel()
        {
            /*
            //Ref enum EventLogEntryType in msdn
            Error = 1,
            Warning = 2,
            Information = 4,
            SuccessAudit = 8,
            FailureAudit = 16
            */
            switch (LogLevel)
            {
                case "warn":
                    return 2;

                case "error":
                    return 1;

                default:
                    return 4;
            }
        }



        public bool Validate()
        {
            if(IsPropertySet(IncludeEventIds) && IsPropertySet(ExcludeEventIds))
            {
                Console.WriteLine("Either include or exclude can be set at a time!");
                return false;
            }

            if(IsPropertySet(Before) && IsPropertySet(After) && IsPropertySet(Between))
            {
                Console.WriteLine("before, after and between cannot be set together!");
                return false;
            }

            if(IsPropertySet(Before) && IsPropertySet(After))
            {
                Console.WriteLine("before and after cannot be set together!");
                return false;
            }

            if(IsPropertySet(Before) && IsPropertySet(Between))
            {
                Console.WriteLine("before, and between cannot be set together!");
                return false;
            }

            if(IsPropertySet(After) && IsPropertySet(Between))
            {
                Console.WriteLine("after and between cannot be set together!");
                return false;
            }

            return true;
        }


        private static DateTime ConvertToDateTime(string dateValue)
        {

            if (String.IsNullOrEmpty(dateValue))
            {
                return DateTime.MinValue;
            }

            return DateTime.ParseExact(dateValue, "yyyyMMdd", null);
        }


        internal static FilterOptions Build(IDictionary<string, string> argsMap)
        {
            var opts = new FilterOptions();

            string? output;

            if (argsMap.TryGetValue("-include", out output))
                opts.IncludeEventIds = output;

            if (argsMap.TryGetValue("-exclude", out output))
                opts.ExcludeEventIds = output;

            if (argsMap.TryGetValue("-before", out output))
                opts.Before = output;

            if (argsMap.TryGetValue("-after", out output))
                opts.After = output;

            if (argsMap.TryGetValue("-between", out output))
                opts.Between = output;

            if (argsMap.TryGetValue("-logLevel", out output))
            {
                opts.LogLevel = output;
            }

            return opts;
        }
    }
}